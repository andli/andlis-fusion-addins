# PatternedCount.py
# Auto-numbered sketch text for patterned counter segments.
#
# Usage:
# 1. Create user parameters:
#    - pcSegmentCount   (unitless int, e.g. 10)
#    - pcSegmentPitch   (length, e.g. 6 mm)
#    - pcStartNumber    (unitless int, e.g. 0)
#    - pcDirection      (text: "+X", "-X", "+Y", "-Y"; optional, default "+X")
#    - pcCutDepth       (length, e.g. 0.4 mm; optional - enables cut/body creation)
#
# 2. Create a sketch on a face, add ONE Sketch Text as the template.
# 3. Select the sketch in the browser (or edit it).
# 4. Run this script from Scripts & Add-Ins.

import adsk.core
import adsk.fusion
import traceback

# Prefix for generated features - only items with this prefix will be auto-deleted
GENERATED_PREFIX = "pc#"
# Attribute group/name used to tag generated sketch texts
ATTR_GROUP = "PatternedCount"
ATTR_NAME = "generated"


def _get_user_param(design, name, required=True):
    params = design.userParameters
    p = params.itemByName(name)
    if not p and required:
        raise RuntimeError(f'Missing user parameter "{name}".')
    return p


def _find_sketch(design, ui):
    """Find the target sketch by selection or active edit object."""
    # First, check if user has a sketch selected
    sel = ui.activeSelections
    if sel.count == 1:
        sketch = adsk.fusion.Sketch.cast(sel.item(0).entity)
        if sketch:
            return sketch

    # Check if we're currently editing a sketch
    app = adsk.core.Application.get()
    edit_obj = app.activeEditObject
    sketch = adsk.fusion.Sketch.cast(edit_obj)
    if sketch:
        return sketch

    return None


def _is_generated(text):
    """Check if a SketchText was generated by this script (has our attribute)."""
    attr = text.attributes.itemByName(ATTR_GROUP, ATTR_NAME)
    return attr is not None


def _find_template_text(sketch, ui):
    """Find the template text in the sketch (non-generated text)."""
    texts = sketch.sketchTexts
    if texts.count == 0:
        return None

    # Find texts that are NOT generated (don't have our attribute)
    non_generated = []
    for i in range(texts.count):
        t = texts.item(i)
        if not _is_generated(t):
            non_generated.append(t)

    if len(non_generated) == 1:
        return non_generated[0]
    elif len(non_generated) == 0:
        # All texts are generated - should not happen, but fallback to first
        return texts.item(0) if texts.count > 0 else None
    else:
        # Multiple non-generated texts - check selection
        sel = ui.activeSelections
        if sel.count == 1:
            selected_text = adsk.fusion.SketchText.cast(sel.item(0).entity)
            if selected_text and selected_text.parentSketch == sketch:
                return selected_text
        return None


def _delete_generated_features(design):
    """Delete previously generated extrude features."""
    for comp in design.allComponents:
        features = comp.features.extrudeFeatures
        # Iterate in reverse to safely delete
        for i in range(features.count - 1, -1, -1):
            f = features.item(i)
            if f.name.startswith(GENERATED_PREFIX):
                f.deleteMe()


def run(context):
    ui = None
    timeline_start = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface

        design = adsk.fusion.Design.cast(app.activeProduct)
        if not design:
            ui.messageBox('PatternedCount: No active Fusion design.')
            return

        # Start a timeline group so all operations can be undone at once
        timeline = design.timeline
        timeline_start = timeline.markerPosition

        # --- Find the sketch ---
        sketch = _find_sketch(design, ui)
        if not sketch:
            ui.messageBox(
                'PatternedCount:\n'
                'No sketch found. Select a sketch in the browser or edit a sketch, '
                'then run the script again.'
            )
            return

        # --- Find the template text ---
        template_text = _find_template_text(sketch, ui)
        if not template_text:
            ui.messageBox(
                'PatternedCount:\n'
                'Could not determine template text. Ensure the sketch has exactly '
                'one non-generated text, or select the template text.'
            )
            return

        # --- Read parameters ---
        seg_count_param = _get_user_param(design, 'pcSegmentCount')
        pitch_param = _get_user_param(design, 'pcSegmentPitch')
        start_param = _get_user_param(design, 'pcStartNumber')
        # Optional ones
        dir_param = _get_user_param(design, 'pcDirection', required=False)
        cut_depth_param = _get_user_param(design, 'pcCutDepth', required=False)

        seg_count = int(round(seg_count_param.value))
        if seg_count < 1:
            ui.messageBox('PatternedCount: pcSegmentCount must be at least 1.')
            return

        pitch = pitch_param.value  # internal length units (cm)
        start_number = int(round(start_param.value))

        # Direction: "+X", "-X", "+Y", "-Y" (default "+X")
        dir_x = 1
        dir_y = 0
        if dir_param:
            # Text params: expression contains the quoted string, e.g. "'+Y'"
            dir_str = dir_param.expression.strip().strip("'\"").upper()
            if dir_str == "-X":
                dir_x, dir_y = -1, 0
            elif dir_str == "+Y":
                dir_x, dir_y = 0, 1
            elif dir_str == "-Y":
                dir_x, dir_y = 0, -1
            # else default "+X"

        cut_depth = None
        if cut_depth_param:
            cut_depth = cut_depth_param.value  # internal units (cm)

        # --- If editing sketch, finish it first for text generation ---
        was_editing = False
        if app.activeEditObject == sketch:
            was_editing = True
            # We'll continue editing for now, finish later if needed

        # --- Make sure we're editing the sketch to modify texts ---
        if not was_editing:
            sketch.isLightBulbOn = True
            # Need to edit sketch to add/modify texts
            # This is done by accessing sketch texts directly - no edit mode needed for API

        texts = sketch.sketchTexts

        # --- Make sure template shows the start number ---
        template_param = template_text.textParameter
        label0 = str(start_number)
        template_param.expression = f"'{label0}'"

        # --- Determine template center in sketch space ---
        tpl_box = template_text.boundingBox
        tpl_min = tpl_box.minPoint
        tpl_max = tpl_box.maxPoint
        base_cx = (tpl_min.x + tpl_max.x) * 0.5
        base_cy = (tpl_min.y + tpl_max.y) * 0.5

        # --- Auto-delete: only remove texts we previously generated (have our attribute) ---
        for i in range(texts.count - 1, -1, -1):
            t = texts.item(i)
            if _is_generated(t):
                t.deleteMe()

        # --- Get template properties for new texts ---
        height_param = template_text.heightParameter
        text_height = height_param.value  # internal length (cm)
        try:
            template_angle = template_text.angle  # rotation in radians
        except:
            template_angle = 0.0
        try:
            template_h_flip = template_text.isHorizontalFlip
            template_v_flip = template_text.isVerticalFlip
        except:
            template_h_flip = False
            template_v_flip = False

        # Convenience
        horiz_align = adsk.core.HorizontalAlignments.CenterHorizontalAlignment
        vert_align = adsk.core.VerticalAlignments.MiddleVerticalAlignment

        # --- Generate texts for segments 1..seg_count-1 ---
        for i in range(1, seg_count):
            n = start_number + i
            label = str(n)

            # Target center for this segment
            step = i * pitch
            target_cx = base_cx + step * dir_x
            target_cy = base_cy + step * dir_y

            # Copy the template text and move it to target position
            copy_coll = adsk.core.ObjectCollection.create()
            copy_coll.add(template_text)
            new_entities = sketch.copy(copy_coll, adsk.core.Matrix3D.create())
            new_text = adsk.fusion.SketchText.cast(new_entities.item(0))

            # Update the text content
            new_text.textParameter.expression = f"'{label}'"
            # Tag as generated so we can identify and delete it later
            new_text.attributes.add(ATTR_GROUP, ATTR_NAME, label)

            # Compute its current center
            nb = new_text.boundingBox
            nmin = nb.minPoint
            nmax = nb.maxPoint
            cur_cx = (nmin.x + nmax.x) * 0.5
            cur_cy = (nmin.y + nmax.y) * 0.5

            # Translation vector from current center to target center
            dx = target_cx - cur_cx
            dy = target_cy - cur_cy

            xform = adsk.core.Matrix3D.create()
            xform.translation = adsk.core.Vector3D.create(dx, dy, 0)

            coll = adsk.core.ObjectCollection.create()
            coll.add(new_text)
            sketch.move(coll, xform)

        # --- Create cuts and bodies if pcCutDepth is set ---
        bodies_created = 0
        profiles_in_text = 0
        if cut_depth and cut_depth > 0:
            # Make sure we're not in sketch edit mode - exit if needed
            if app.activeEditObject and app.activeEditObject.classType == adsk.fusion.Sketch.classType:
                sketch.isLightBulbOn = True  # Keep it visible
                app.activeViewport.refresh()
                design.rootComponent.activate()  # Exit sketch mode

            # Delete previously generated extrude features
            _delete_generated_features(design)

            # Get the component containing the sketch
            comp = sketch.parentComponent

            # Collect all text bounding boxes and their numbers before exploding
            text_boxes = []
            for i in range(texts.count):
                t = texts.item(i)
                bb = t.boundingBox
                # Get the number from the text content
                text_content = t.text
                text_boxes.append({
                    'min': bb.minPoint,
                    'max': bb.maxPoint,
                    'number': text_content
                })

            # Explode all texts to create actual curve profiles
            # (Note: this is destructive - texts become curves)
            texts_to_explode = []
            for i in range(texts.count):
                texts_to_explode.append(texts.item(i))

            for t in texts_to_explode:
                # Workaround for API bug: make a small edit first
                try:
                    t.textParameter.expression = t.textParameter.expression
                except:
                    pass
                try:
                    t.explode()
                except:
                    pass

            # Recompute to ensure profiles are available
            adsk.doEvents()

            # First pass: collect all profile areas that are inside text bounding boxes
            # to determine what a "normal" character area looks like
            profile_areas = []
            profiles = sketch.profiles

            for i in range(profiles.count):
                profile = profiles.item(i)
                try:
                    area_props = profile.areaProperties()
                    centroid = area_props.centroid
                    area = area_props.area
                    cx, cy = centroid.x, centroid.y

                    # Check if centroid is in any text box
                    for (min_pt, max_pt) in text_boxes:
                        if (min_pt.x <= cx <= max_pt.x and
                            min_pt.y <= cy <= max_pt.y):
                            profile_areas.append(area)
                            break
                except:
                    pass

            # Calculate threshold: median area * 3 should filter outliers (big boundary profiles)
            if profile_areas:
                sorted_areas = sorted(profile_areas)
                median_area = sorted_areas[len(sorted_areas) // 2]
                max_char_area = median_area * 3
            else:
                max_char_area = pitch * text_height * 2

            # Helper to check if a profile contains projected geometry
            def has_projected_curves(profile):
                try:
                    for loop in profile.profileLoops:
                        for curve in loop.profileCurves:
                            ent = curve.sketchEntity
                            # Check if it's a projected entity (references external geometry)
                            if hasattr(ent, 'isReference') and ent.isReference:
                                return True
                except:
                    pass
                return False

            # Collect valid text profiles with their bounding boxes
            valid_profiles = []
            profiles = sketch.profiles

            for i in range(profiles.count):
                profile = profiles.item(i)
                try:
                    # Skip profiles that contain projected geometry
                    if has_projected_curves(profile):
                        continue

                    area_props = profile.areaProperties()
                    centroid = area_props.centroid
                    area = area_props.area
                    cx, cy = centroid.x, centroid.y

                    # Skip profiles that are too large (likely outer boundaries)
                    if area > max_char_area:
                        continue

                    # Check if centroid is in any text box
                    matched_number = None
                    for tb in text_boxes:
                        min_pt, max_pt = tb['min'], tb['max']
                        if (min_pt.x <= cx <= max_pt.x and
                            min_pt.y <= cy <= max_pt.y):
                            matched_number = tb['number']
                            break

                    if matched_number is not None:
                        # Get profile bounding box
                        bb = profile.boundingBox
                        valid_profiles.append({
                            'profile': profile,
                            'area': area,
                            'centroid': (cx, cy),
                            'min': (bb.minPoint.x, bb.minPoint.y),
                            'max': (bb.maxPoint.x, bb.maxPoint.y),
                            'number': matched_number
                        })
                except:
                    pass

            # Filter out inner profiles (holes inside other profiles)
            # A profile is an "inner hole" if its bounding box is fully contained within another profile's bounding box
            def is_contained_in(inner, outer):
                return (outer['min'][0] < inner['min'][0] and
                        outer['min'][1] < inner['min'][1] and
                        outer['max'][0] > inner['max'][0] and
                        outer['max'][1] > inner['max'][1])

            outer_profiles = []
            for p in valid_profiles:
                is_inner = False
                for other in valid_profiles:
                    if p is not other and is_contained_in(p, other):
                        is_inner = True
                        break
                if not is_inner:
                    outer_profiles.append(p)  # Keep full dict with number

            profiles_in_text = len(outer_profiles)

            if len(outer_profiles) == 0:
                ui.messageBox(
                    'PatternedCount:\n'
                    'No valid text profiles found in sketch. Cannot create cuts/bodies.\n'
                    'Ensure the sketch is on a face of an existing body.'
                )
            else:
                extrudes = comp.features.extrudeFeatures
                cuts_created = 0
                cut_errors = []
                body_errors = []

                # Collect all outer profiles into an ObjectCollection for a single operation
                # Also build a list of numbers in the same order
                profile_collection = adsk.core.ObjectCollection.create()
                profile_numbers = []
                for p in outer_profiles:
                    profile_collection.add(p['profile'])
                    profile_numbers.append(p['number'])

                # Create a single cut with all profiles
                if profile_collection.count > 0:
                    cut_input = extrudes.createInput(
                        profile_collection,
                        adsk.fusion.FeatureOperations.CutFeatureOperation
                    )
                    cut_distance = adsk.core.ValueInput.createByReal(-cut_depth)
                    cut_input.setDistanceExtent(False, cut_distance)
                    try:
                        cut_feature = extrudes.add(cut_input)
                        cut_feature.name = f"{GENERATED_PREFIX}cuts"
                        cuts_created = profile_collection.count
                    except Exception as e:
                        cut_errors.append(str(e))

                    # Create new bodies from the cut's end faces (bottom of pockets)
                    if cuts_created > 0:
                        try:
                            # Get the end faces created by the cut
                            end_faces = cut_feature.endFaces
                            end_face_count = end_faces.count

                            # Get sketch transform to convert model coords to sketch coords
                            sketch_transform = sketch.transform
                            sketch_transform_inv = sketch_transform.copy()
                            sketch_transform_inv.invert()

                            # Add small tolerance for centroid matching
                            tol = pitch * 0.5

                            for j in range(end_face_count):
                                face = end_faces.item(j)
                                try:
                                    # Find which number this face corresponds to by matching centroid to text boxes
                                    face_centroid = face.centroid

                                    # Transform face centroid from model space to sketch space
                                    sketch_centroid = face_centroid.copy()
                                    sketch_centroid.transformBy(sketch_transform_inv)
                                    fcx, fcy = sketch_centroid.x, sketch_centroid.y

                                    face_number = None
                                    for tb in text_boxes:
                                        min_pt, max_pt = tb['min'], tb['max']
                                        # Use tolerance for matching
                                        if (min_pt.x - tol <= fcx <= max_pt.x + tol and
                                            min_pt.y - tol <= fcy <= max_pt.y + tol):
                                            face_number = tb['number']
                                            break

                                    body_input = extrudes.createInput(
                                        face,
                                        adsk.fusion.FeatureOperations.NewBodyFeatureOperation
                                    )
                                    # Extrude up by cut_depth from the face
                                    body_distance = adsk.core.ValueInput.createByReal(cut_depth)
                                    body_input.setDistanceExtent(False, body_distance)
                                    body_feature = extrudes.add(body_input)

                                    # Name the feature (for timeline) with our prefix
                                    body_feature.name = f"{GENERATED_PREFIX}body_{j}"

                                    # Name only the newly created bodies (not existing ones)
                                    # NewBodyFeatureOperation creates exactly one new body
                                    if body_feature.bodies.count > 0:
                                        new_body = body_feature.bodies.item(0)
                                        if face_number is not None:
                                            new_body.name = f"n{face_number}"

                                    bodies_created += 1
                                except Exception as e:
                                    body_errors.append(f"Face {j}: {str(e)}")
                        except Exception as e:
                            body_errors.append(str(e))

        # --- Report results ---
        msg = f'PatternedCount: Created {seg_count} sketch text numbers starting at {start_number}.'
        if cut_depth and cut_depth > 0:
            msg += f'\nValid profiles: {len(valid_profiles)}, outer (non-hole): {profiles_in_text}'
            msg += f'\nCuts: {cuts_created}, Bodies: {bodies_created}'
            if cut_errors:
                msg += f'\nCut errors: {cut_errors[0]}'
            if body_errors:
                msg += f'\nBody errors: {body_errors[0]}'
        ui.messageBox(msg)

        # Group all timeline operations into one undo step (needs at least 2 features)
        if timeline_start is not None:
            timeline_end = timeline.markerPosition
            if timeline_end - timeline_start >= 2:
                try:
                    timeline_group = timeline.timelineGroups.add(timeline_start, timeline_end - 1)
                    timeline_group.name = "PatternedCount"
                except:
                    pass  # Grouping failed, not critical

    except Exception:
        if ui:
            ui.messageBox('PatternedCount failed:\n{}'.format(traceback.format_exc()))


def stop(context):
    # Called when the script/add-in is stopped
    pass