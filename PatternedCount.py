# PatternedCount.py
# Auto-numbered sketch text for patterned counter segments.
#
# Usage:
# 1. Create user parameters:
#    - pcSegmentCount   (unitless int, e.g. 10)
#    - pcSegmentPitch   (length, e.g. 6 mm)
#    - pcStartNumber    (unitless int, e.g. 0)
#    - pcDirection      (text: "+X", "-X", "+Y", "-Y"; optional, default "+X")
#    - pcCutDepth       (length, e.g. 0.4 mm; optional - enables cut/body creation)
#
# 2. Create a sketch on a face, add ONE Sketch Text as the template.
# 3. Select the sketch in the browser (or edit it).
# 4. Run this script from Scripts & Add-Ins.

import adsk.core
import adsk.fusion
import traceback

# Prefix for generated features - only items with this prefix will be auto-deleted
GENERATED_PREFIX = "pc#"
# Attribute group/name used to tag generated sketch texts
ATTR_GROUP = "PatternedCount"
ATTR_NAME = "generated"


def _get_user_param(design, name, required=True):
    params = design.userParameters
    p = params.itemByName(name)
    if not p and required:
        raise RuntimeError(f'Missing user parameter "{name}".')
    return p


def _find_sketch(design, ui):
    """Find the target sketch by selection or active edit object."""
    # First, check if user has a sketch selected
    sel = ui.activeSelections
    if sel.count == 1:
        sketch = adsk.fusion.Sketch.cast(sel.item(0).entity)
        if sketch:
            return sketch

    # Check if we're currently editing a sketch
    app = adsk.core.Application.get()
    edit_obj = app.activeEditObject
    sketch = adsk.fusion.Sketch.cast(edit_obj)
    if sketch:
        return sketch

    return None


def _is_generated(text):
    """Check if a SketchText was generated by this script (has our attribute)."""
    attr = text.attributes.itemByName(ATTR_GROUP, ATTR_NAME)
    return attr is not None


def _find_template_text(sketch, ui):
    """Find the template text in the sketch (non-generated text)."""
    texts = sketch.sketchTexts
    if texts.count == 0:
        return None

    # Find texts that are NOT generated (don't have our attribute)
    non_generated = []
    for i in range(texts.count):
        t = texts.item(i)
        if not _is_generated(t):
            non_generated.append(t)

    if len(non_generated) == 1:
        return non_generated[0]
    elif len(non_generated) == 0:
        # All texts are generated - should not happen, but fallback to first
        return texts.item(0) if texts.count > 0 else None
    else:
        # Multiple non-generated texts - check selection
        sel = ui.activeSelections
        if sel.count == 1:
            selected_text = adsk.fusion.SketchText.cast(sel.item(0).entity)
            if selected_text and selected_text.parentSketch == sketch:
                return selected_text
        return None


def _delete_generated_features(design):
    """Delete previously generated extrude features."""
    for comp in design.allComponents:
        features = comp.features.extrudeFeatures
        # Iterate in reverse to safely delete
        for i in range(features.count - 1, -1, -1):
            f = features.item(i)
            if f.name.startswith(GENERATED_PREFIX):
                f.deleteMe()


def run(context):
    ui = None
    timeline_start = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface

        design = adsk.fusion.Design.cast(app.activeProduct)
        if not design:
            ui.messageBox('PatternedCount: No active Fusion design.')
            return

        # Start a timeline group so all operations can be undone at once
        timeline = design.timeline
        timeline_start = timeline.markerPosition

        # --- Find the sketch ---
        sketch = _find_sketch(design, ui)
        if not sketch:
            ui.messageBox(
                'PatternedCount:\n'
                'No sketch found. Select a sketch in the browser or edit a sketch, '
                'then run the script again.'
            )
            return

        # --- Find the template text ---
        template_text = _find_template_text(sketch, ui)
        if not template_text:
            ui.messageBox(
                'PatternedCount:\n'
                'Could not determine template text. Ensure the sketch has exactly '
                'one non-generated text, or select the template text.'
            )
            return

        # --- Read parameters ---
        seg_count_param = _get_user_param(design, 'pcSegmentCount')
        pitch_param = _get_user_param(design, 'pcSegmentPitch')
        start_param = _get_user_param(design, 'pcStartNumber')
        # Optional ones
        dir_param = _get_user_param(design, 'pcDirection', required=False)
        cut_depth_param = _get_user_param(design, 'pcCutDepth', required=False)

        seg_count = int(round(seg_count_param.value))
        if seg_count < 1:
            ui.messageBox('PatternedCount: pcSegmentCount must be at least 1.')
            return

        pitch = pitch_param.value  # internal length units (cm)
        start_number = int(round(start_param.value))

        # Direction: "+X", "-X", "+Y", "-Y" (default "+X")
        dir_x = 1
        dir_y = 0
        if dir_param:
            # Text params: expression contains the quoted string, e.g. "'+Y'"
            dir_str = dir_param.expression.strip().strip("'\"").upper()
            if dir_str == "-X":
                dir_x, dir_y = -1, 0
            elif dir_str == "+Y":
                dir_x, dir_y = 0, 1
            elif dir_str == "-Y":
                dir_x, dir_y = 0, -1
            # else default "+X"

        cut_depth = None
        if cut_depth_param:
            cut_depth = cut_depth_param.value  # internal units (cm)

        # --- If editing sketch, finish it first for text generation ---
        was_editing = False
        if app.activeEditObject == sketch:
            was_editing = True
            # We'll continue editing for now, finish later if needed

        # --- Make sure we're editing the sketch to modify texts ---
        if not was_editing:
            sketch.isLightBulbOn = True
            # Need to edit sketch to add/modify texts
            # This is done by accessing sketch texts directly - no edit mode needed for API

        texts = sketch.sketchTexts

        # --- Make sure template shows the start number ---
        template_param = template_text.textParameter
        label0 = str(start_number)
        template_param.expression = f"'{label0}'"

        # --- Determine template center in sketch space ---
        tpl_box = template_text.boundingBox
        tpl_min = tpl_box.minPoint
        tpl_max = tpl_box.maxPoint
        base_cx = (tpl_min.x + tpl_max.x) * 0.5
        base_cy = (tpl_min.y + tpl_max.y) * 0.5

        # --- Auto-delete: only remove texts we previously generated (have our attribute) ---
        for i in range(texts.count - 1, -1, -1):
            t = texts.item(i)
            if _is_generated(t):
                t.deleteMe()

        # --- Get template properties for new texts ---
        height_param = template_text.heightParameter
        text_height = height_param.value  # internal length (cm)
        try:
            template_angle = template_text.angle  # rotation in radians
        except:
            template_angle = 0.0
        try:
            template_h_flip = template_text.isHorizontalFlip
            template_v_flip = template_text.isVerticalFlip
        except:
            template_h_flip = False
            template_v_flip = False

        # Convenience
        horiz_align = adsk.core.HorizontalAlignments.CenterHorizontalAlignment
        vert_align = adsk.core.VerticalAlignments.MiddleVerticalAlignment

        # --- Generate texts for segments 1..seg_count-1 ---
        for i in range(1, seg_count):
            n = start_number + i
            label = str(n)

            # Target center for this segment
            step = i * pitch
            target_cx = base_cx + step * dir_x
            target_cy = base_cy + step * dir_y

            # Copy the template text and move it to target position
            copy_coll = adsk.core.ObjectCollection.create()
            copy_coll.add(template_text)
            new_entities = sketch.copy(copy_coll, adsk.core.Matrix3D.create())
            new_text = adsk.fusion.SketchText.cast(new_entities.item(0))

            # Update the text content
            new_text.textParameter.expression = f"'{label}'"
            # Tag as generated so we can identify and delete it later
            new_text.attributes.add(ATTR_GROUP, ATTR_NAME, label)

            # Compute its current center
            nb = new_text.boundingBox
            nmin = nb.minPoint
            nmax = nb.maxPoint
            cur_cx = (nmin.x + nmax.x) * 0.5
            cur_cy = (nmin.y + nmax.y) * 0.5

            # Translation vector from current center to target center
            dx = target_cx - cur_cx
            dy = target_cy - cur_cy

            xform = adsk.core.Matrix3D.create()
            xform.translation = adsk.core.Vector3D.create(dx, dy, 0)

            coll = adsk.core.ObjectCollection.create()
            coll.add(new_text)
            sketch.move(coll, xform)

        # --- Create cuts and bodies if pcCutDepth is set ---
        bodies_created = 0
        profiles_in_text = 0
        if cut_depth and cut_depth > 0:
            # Make sure we're not in sketch edit mode - exit if needed
            if app.activeEditObject and app.activeEditObject.classType == adsk.fusion.Sketch.classType:
                sketch.isLightBulbOn = True  # Keep it visible
                app.activeViewport.refresh()
                design.rootComponent.activate()  # Exit sketch mode

            # Delete previously generated extrude features
            _delete_generated_features(design)

            # Get the component containing the sketch
            comp = sketch.parentComponent

            # Collect all text bounding boxes before exploding
            text_boxes = []
            for i in range(texts.count):
                t = texts.item(i)
                bb = t.boundingBox
                text_boxes.append((bb.minPoint, bb.maxPoint))

            # Explode all texts to create actual curve profiles
            # (Note: this is destructive - texts become curves)
            texts_to_explode = []
            for i in range(texts.count):
                texts_to_explode.append(texts.item(i))

            for t in texts_to_explode:
                # Workaround for API bug: make a small edit first
                try:
                    t.textParameter.expression = t.textParameter.expression
                except:
                    pass
                try:
                    t.explode()
                except:
                    pass

            # Recompute to ensure profiles are available
            adsk.doEvents()

            # First pass: collect all profile areas that are inside text bounding boxes
            # to determine what a "normal" character area looks like
            profile_areas = []
            profiles = sketch.profiles

            for i in range(profiles.count):
                profile = profiles.item(i)
                try:
                    area_props = profile.areaProperties()
                    centroid = area_props.centroid
                    area = area_props.area
                    cx, cy = centroid.x, centroid.y

                    # Check if centroid is in any text box
                    for (min_pt, max_pt) in text_boxes:
                        if (min_pt.x <= cx <= max_pt.x and
                            min_pt.y <= cy <= max_pt.y):
                            profile_areas.append(area)
                            break
                except:
                    pass

            # Calculate threshold: median area * 3 should filter outliers (big boundary profiles)
            if profile_areas:
                sorted_areas = sorted(profile_areas)
                median_area = sorted_areas[len(sorted_areas) // 2]
                max_char_area = median_area * 3
            else:
                max_char_area = pitch * text_height * 2

            # Helper to check if a profile contains projected geometry
            def has_projected_curves(profile):
                try:
                    for loop in profile.profileLoops:
                        for curve in loop.profileCurves:
                            ent = curve.sketchEntity
                            # Check if it's a projected entity (references external geometry)
                            if hasattr(ent, 'isReference') and ent.isReference:
                                return True
                except:
                    pass
                return False

            # Helper to check if a profile is a valid text character
            def is_text_profile(profile):
                try:
                    # Skip profiles that contain projected geometry
                    if has_projected_curves(profile):
                        return False

                    area_props = profile.areaProperties()
                    centroid = area_props.centroid
                    area = area_props.area
                    cx, cy = centroid.x, centroid.y

                    # Skip profiles that are too large (likely outer boundaries)
                    if area > max_char_area:
                        return False

                    for (min_pt, max_pt) in text_boxes:
                        if (min_pt.x <= cx <= max_pt.x and
                            min_pt.y <= cy <= max_pt.y):
                            return True
                except:
                    pass
                return False

            profiles = sketch.profiles
            if profiles.count == 0:
                ui.messageBox(
                    'PatternedCount:\n'
                    'No profiles found in sketch. Cannot create cuts/bodies.\n'
                    'Ensure the sketch is on a face of an existing body.'
                )
            else:
                extrudes = comp.features.extrudeFeatures
                cut_idx = 0

                for i in range(profiles.count):
                    profile = profiles.item(i)

                    # Only process profiles that are valid text characters
                    if not is_text_profile(profile):
                        continue
                    profiles_in_text += 1

                    # Create cut into body
                    cut_input = extrudes.createInput(
                        profile,
                        adsk.fusion.FeatureOperations.CutFeatureOperation
                    )
                    cut_distance = adsk.core.ValueInput.createByReal(-cut_depth)
                    cut_input.setDistanceExtent(False, cut_distance)
                    try:
                        cut_feature = extrudes.add(cut_input)
                        cut_feature.name = f"{GENERATED_PREFIX}cut_{cut_idx}"
                    except:
                        # Profile might not intersect a body - skip
                        continue

                    # Create new body by extruding from the cut bottom
                    # Use offset start to begin at -cut_depth, extrude up by cut_depth
                    try:
                        body_input = extrudes.createInput(
                            profile,
                            adsk.fusion.FeatureOperations.NewBodyFeatureOperation
                        )
                        # Set start offset to -cut_depth (down into the cut)
                        start_offset = adsk.core.ValueInput.createByReal(-cut_depth)
                        body_input.startExtent = adsk.fusion.OffsetStartDefinition.create(start_offset)
                        body_distance = adsk.core.ValueInput.createByReal(cut_depth)
                        body_input.setDistanceExtent(False, body_distance)
                        body_feature = extrudes.add(body_input)
                        body_feature.name = f"{GENERATED_PREFIX}body_{cut_idx}"
                        bodies_created += 1
                    except:
                        pass

                    cut_idx += 1

        # --- Report results ---
        msg = f'PatternedCount: Created {seg_count} numbers starting at {start_number}.'
        if cut_depth and cut_depth > 0:
            msg += f'\nCut/body pairs created: {bodies_created}'
        ui.messageBox(msg)

        # Group all timeline operations into one undo step
        if timeline_start is not None:
            timeline_end = timeline.markerPosition
            if timeline_end > timeline_start:
                timeline_group = timeline.timelineGroups.add(timeline_start, timeline_end - 1)
                timeline_group.name = "PatternedCount"

    except Exception:
        if ui:
            ui.messageBox('PatternedCount failed:\n{}'.format(traceback.format_exc()))


def stop(context):
    # Called when the script/add-in is stopped
    pass